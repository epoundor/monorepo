"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decorateStory = decorateStory;

require("core-js/modules/es.function.name.js");

require("core-js/modules/es.object.assign.js");

require("core-js/modules/es.object.to-string.js");

var _vue = require("vue");

var _store = require("@storybook/store");

/*
  This normalizes a functional component into a render method in ComponentOptions.

  The concept is taken from Vue 3's `defineComponent` but changed from creating a `setup`
  method on the ComponentOptions so end-users don't need to specify a "thunk" as a decorator.
 */
function normalizeFunctionalComponent(options) {
  return typeof options === 'function' ? {
    render: options,
    name: options.name
  } : options;
}

function prepare(rawStory, innerStory) {
  var story = rawStory;

  if (story == null) {
    return null;
  }

  if (innerStory) {
    return Object.assign({}, normalizeFunctionalComponent(story), {
      components: Object.assign({}, story.components || {}, {
        story: innerStory
      })
    });
  }

  return {
    render: function render() {
      return (0, _vue.h)(story);
    }
  };
}

function decorateStory(storyFn, decorators) {
  return decorators.reduce(function (decorated, decorator) {
    return function (context) {
      var story;
      var decoratedStory = decorator(function (update) {
        story = decorated(Object.assign({}, context, (0, _store.sanitizeStoryContextUpdate)(update)));
        return story;
      }, context);

      if (!story) {
        story = decorated(context);
      }

      if (decoratedStory === story) {
        return story;
      }

      return prepare(decoratedStory, story);
    };
  }, function (context) {
    return prepare(storyFn(context));
  });
}